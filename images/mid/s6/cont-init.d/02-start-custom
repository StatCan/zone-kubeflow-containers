#!/command/with-contenv bash

echo "--------------------Starting up--------------------"

# -------------------- S6 Overlay Environment --------------------
S6_ENV="/run/s6-env"
mkdir -p "${S6_ENV}"

# -------------------- RStudio / Jupyter Proxy --------------------
export RSERVER_WWW_ROOT_PATH="${NB_PREFIX}/rstudio"
echo "${RSERVER_WWW_ROOT_PATH}" > "${S6_ENV}/RSERVER_WWW_ROOT_PATH"

export NB_NAMESPACE=$(echo "$NB_PREFIX" | awk -F '/' '{print $3}')
echo "${NB_NAMESPACE}" > "${S6_ENV}/NB_NAMESPACE"

# JWT token
export JWT="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)"
echo "${JWT}" > "${S6_ENV}/JWT"

# -------------------- R Environment --------------------
RENVCFG="/opt/conda/lib/R/etc/Renviron"

# Append environment variables to R environment
{
  echo "NB_PREFIX=${NB_PREFIX}"
  echo "NB_NAMESPACE=${NB_NAMESPACE}"
  echo "NLS_LANG=${NLS_LANG}"
  printenv | grep KUBERNETES
  echo "SPARK_HOME=${SPARK_HOME}"
  printenv | grep svm
} >> "${RENVCFG}"

# -------------------- Conda Channels --------------------
serviceaccountname=$(kubectl get secret artifactory-creds -n "$NB_NAMESPACE" --template={{.data.Username}} | base64 --decode)
serviceaccounttoken=$(kubectl get secret artifactory-creds -n "$NB_NAMESPACE" --template={{.data.Token}} | base64 --decode)

conda config --add channels "https://$serviceaccountname:$serviceaccounttoken@artifactory.cloud.statcan.ca/artifactory/conda-forge-remote/"
conda config --add channels "https://$serviceaccountname:$serviceaccounttoken@artifactory.cloud.statcan.ca/artifactory/conda-pytorch-remote/"
conda config --add channels "https://$serviceaccountname:$serviceaccounttoken@artifactory.cloud.statcan.ca/artifactory/conda-nvidia-remote/"
conda config --remove channels 'defaults'
conda config --remove channels conda-forge --system

pip config set global.index-url "https://$serviceaccountname:$serviceaccounttoken@artifactory.cloud.statcan.ca/artifactory/api/pypi/pypi/simple"

# -------------------- Pixi Config --------------------
PIXICONF="/home/${NB_USER}/.pixi/config.toml"
if [ ! -f "$PIXICONF" ]; then
  mkdir -p "$(dirname "$PIXICONF")"
  cat > "$PIXICONF" <<EOF
default-channels = ["https://$serviceaccountname:$serviceaccounttoken@artifactory.cloud.statcan.ca/artifactory/conda-forge-remote/"]
EOF
fi

# -------------------- Rprofile.site (future-proof) --------------------
RPROFILE="/opt/conda/lib/R/etc/Rprofile.site"
if [ ! -f "$RPROFILE" ]; then
  cat > "$RPROFILE" <<'EOF'
# --- Ensure user library exists ---
dir.create(Sys.getenv("R_LIBS_USER"), recursive = TRUE, showWarnings = FALSE)

# --- Set repos dynamically based on R version ---
rver <- paste0(R.Version()$major, ".", R.Version()$minor)
serviceaccountname <- Sys.getenv("ARTIFACTORY_USER")
serviceaccounttoken <- Sys.getenv("ARTIFACTORY_TOKEN")
options(
  repos = list(
    "ppm" = paste0("https://", serviceaccountname, ":", serviceaccounttoken, "@artifactory.cloud.statcan.ca/artifactory/zone-r-ppm-bin-noble-", rver, "-remote")
  )
)

# --- Future-proof migration helper ---
migrate_old_packages <- function() {
  new_lib <- Sys.getenv("R_LIBS_USER")
  dir.create(new_lib, recursive = TRUE, showWarnings = FALSE)
  
  # Skip if migration already done
  if (file.exists("~/.migration_done")) {
    message("Migration already done.")
    return(invisible(TRUE))
  }
  
  # Detect previous R version libraries in ~/R
  r_dir <- "~/R"
  if (!dir.exists(r_dir)) return(message("No previous R libraries found."))

  old_libs <- list.dirs(r_dir, recursive = FALSE, full.names = TRUE)
  
  # Only consider directories with version lower than current
  current_version <- as.numeric(paste0(R.Version()$major, ".", R.Version()$minor))
  version_from_dir <- function(dir) as.numeric(sub(".*([0-9]+\\.[0-9]+)$", "\\1", dir))
  old_libs <- old_libs[sapply(old_libs, function(d) {
    v <- version_from_dir(d)
    !is.na(v) && v < current_version
  })]
  
  if (length(old_libs) == 0) {
    message("No previous R libraries to migrate from.")
    file.create("~/.migration_done")
    return(invisible(TRUE))
  }
  
  # Pick the latest previous version
  old_lib <- old_libs[which.max(sapply(old_libs, version_from_dir))]
  
  # Only migrate if current library is empty
  if (length(list.files(new_lib)) == 0) {
    pkgs <- list.files(old_lib)
    if (length(pkgs) > 0) {
      message("Migrating ", length(pkgs), " packages from ", old_lib, " â†’ ", new_lib)
      install.packages(pkgs, lib=new_lib, repos=getOption("repos"))
    }
  } else {
    message("Current library not empty; skipping migration.")
  }
  
  file.create("~/.migration_done")
  message("Migration complete.")
}
EOF
fi

# -------------------- Language Configuration --------------------
if [ -n "${KF_LANG}" ]; then
    if [ "${KF_LANG}" = "en" ]; then
        export LANG="en_US.utf8"
    else
        export LANG="fr_FR.utf8"
        
        # JupyterLab language settings
        lang_file="/home/${NB_USER}/.jupyter/lab/user-settings/@jupyterlab/translation-extension/plugin.jupyterlab-settings"
        if [ ! -e "${lang_file}" ]; then
            mkdir -p "$(dirname "${lang_file}")"
            cat > "${lang_file}" << EOF
{
    "locale": "${LANG}"
}
EOF
        fi

        # VS Code language settings
        vscode_language="/home/${NB_USER}/.vscode/User/argv.json"
        if [ ! -e "${vscode_language}" ]; then
            mkdir -p "$(dirname "${vscode_language}")"
            echo "{\"locale\":\"fr\"}" > "${vscode_language}"
        fi
    fi
    echo "${LANG}" > "${S6_ENV}/LANG"
fi

echo "Language configuration complete"

echo "--------------------Startup complete--------------------"
